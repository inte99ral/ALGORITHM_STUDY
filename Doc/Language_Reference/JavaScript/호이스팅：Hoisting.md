# 호이스팅：Hoisting

&nbsp; 사전적인 의미의 호이스팅(hoisting)은 국기의 게양등 위로 올리는 동작을 말합니다.

&nbsp; JavaScript에서 호이스팅(hoisting)이란, 인터프리터가 변수와 함수,클래스 또는 임포트(import)의 선언문의 메모리 공간을 선언 전에 미리 할당하는 것을 의미합니다. 사전에 공간을 할당되어 있다면 선언하기 전에도 해당 변수에 접근이 가능합니다. 마치 인터프리터가 모든 선언을 강제로 맨 위로 끌어올리는 것처럼 보이기에 호이스팅이라는 명칭이 붙었습니다.

&nbsp; 호이스팅은 C++ 언어의 헤더 선언(물론 이 경우엔 실제로 선언을 위로 끌어올린 것 입니다.)과 비슷하게 함수의 호출을 첫 줄에서 하고 마지막 줄에 함수를 정의해도 문제없이 작동되도록 하는 유용한 특성입니다. 이는 JavaScript 가 웹 서비스를 목표로 탄생한 언어이기 때문에, 서버와의 통신 간에 통신 에러나 통신 시간 등의 이슈로 `선언이 없는 정의가 모호한 객체`에 접근할 때, 문제가 발생하지 않도록 만들어 줍니다.

## 호이스팅 제어

&nbsp; JavaScript 가 성장하게 되면서 JavaScript 언어로 개발되는 서비스가 복잡해짐에 따라 호이스팅이 일어나면 안되는 상황 또한 생기기 시작합니다.

&nbsp; 로직과 보안 상의 이슈로 절대로 변수 선언과 값 할당 이전에 접근해서는 안되는 데이터가 있을 수도 있습니다. 이는 여러분의 컴퓨터 디렉토리에 접근하는 주소이거나, 웹 서비스의 여러분의 보안 토큰값이 될 수도 있기에 매우 중요한 문제입니다.

&nbsp; JavaScript는 ES6 문법으로 발전하면서 호이스팅을 제어할 수단을 추가했습니다.

### 호이스팅 제어 > 임시적 분리 구역：const & let

&nbsp; ES6 부터는 기존의 var 에 더하여 const 와 let 이라는 선언 명령을 추가하였습니다.

TDZ(Temporal Dead Zone)는 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 말합니다. 작전에서 봉쇄 및 분리한 지역 또는 통신 무반응 구역을 말하는 군사용어 Dead Zone 에서 따왔습니다.

&nbsp; const 와 let 으로 선언된 객체는 TDZ(Temporal Dead Zone)에서 데이터를 다루게됩니다. 초기화 전에 이 영역 안에 있는 객체에는 접근할 수 없습니다. 선언 전에 호출을 시도할 경우에 작동하지 않고 참조에러 (ReferenceError) 를 던지게 됩니다. 이 중에서 const 는 다른 프로그래밍 언어들과 같이 상수 역할을 수행하며, 한번 값이 초기화되면 값의 수정이 불가능합니다.

&nbsp; 잊지 말아야 하는 부분은 호이스팅은 자바스크립트 인터프리터가 코드를 읽는 방식에서 발생한 현상이기 때문에 const 와 let을 썼다고 호이스팅이 발생하지 않은 것이 아닙니다. 선언들은 스코프 최상위로 끌어올려졌으나 악용할 수 없도록 접근만 막은 것 입니다.

&nbsp; ES6 이후로 실제 현업에서도 var 키워드는 절대로 쓰이지 않으며 99%이상의 경우 모든 함수를 무조건 const와 arrow syntax로 선언합니다. 그렇기 때문에 호이스팅은 var 선언의 기능으로 간주되기도 합니다.

### 호이스팅 제어 > 함수표현식：Function Expressione

&nbsp; 함수는 호이스팅이 가능하지만 변수에 함수를 할당하는 함수표현식은 호이스팅이 불가능합니다. 다음의 예시로 확인해보세요.

```js
console.log(func); // undefined
console.log(func()); // TypeError: asyncFunc is not a function

var func = function () {
  return 'Hello, Async!';
};
```

&nbsp; asyncFunc 이라는 변수의 이름은 호이스팅이 되었기 때문에 undefined 라는 값을 출력하나, asyncFunc가 단순히 변수가 아니라 함수를 표현한 객체라는 사실은 `func = () => {return 'Hello, Async!'}` 로 할당되기 전에는 알 방법이 없습니다. 따라서 함수표현식에서는 호이스팅이 발생하지 않습니다.

&nbsp; 웹 서비스는 여러 병렬적인 계산이 요구됬습니다. 따라서 JavaScript는 비동기 처리 기능을 계속해서 발전해왔습니다. ES5 에서는 콜백함수를 이용하여 비동기 작업을 처리하였으나, ES6 에서 Promise 라는 비동기처리 객체를 추가하였습니다. 그리고 마침내 ES8(ECMAScript 2017) 에 와서 async/await 구문을 추가하여 동기코드와 똑같은 형식으로 높은 가독성과 유지보수성을 지키며 비동기작업을 다룰 수 있게 되었습니다.

&nbsp; async 로 선언된 함수는 비동기 처리를 통하여 프로세스 중에 호출된 시점부터 동작합니다. 위를 이용하면 async 함수의수는 다른 변수들과 마찬가지로 호이스팅은 일어납니다. 하지만 async 함수 표현식의 경우는 이야기가 다릅니다.인터프리터가 읽는 시점에서는 할당 동작 조차 취하지 않았기 때문에 async 함수 표현식은 호이스팅되지 않습니다.

ES8(ECMAScript 2017)에 추가되었습니다

JavaScript에서 비동기 프로그래밍 방식의 발전 과정은 다음과 같습니다:
ES5: 콜백 함수를 사용한 비동기 처리
ES6 (2015): Promise 객체 도입
ES8 (2017): async/await 구문 추가

ES5와 ES6의 비동기 처리
ES5에서는 주로 콜백 함수를 사용하여 비동기 작업을 처리했습니다2.
ES6에서는 Promise가 도입되어 비동기 작업을 더 체계적으로 관리할 수 있게 되었습니다2.
async/await의 장점
async/await는 Promise를 더욱 간결하고 직관적으로 사용할 수 있게 해줍니다. 이를 통해 비동기 코드를 마치 동기 코드처럼 작성할 수 있어, 가독성과 유지보수성이 크게 향상됩니다2.
따라서, async 키워드는 ES5나 ES6에 추가된 것이 아니라, ES8(ECMAScript 2017)에서 정식으로 도입되었습니다.

```javascript

```
