# `D5` [SWEA 20671](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AY5gD-HaQ-MDFAVL)：숫자 카드

## 문제

&nbsp; N개의 카드가 있다. 각각의 카드에는 앞면과 뒷면이 있으며, 카드의 각 면에는 자연수가 10진법으로 적혀 있다. 이 중 i (1≤i≤N)번 카드의 앞면에는 ai, 뒷면에는 bi가 적혀 있다. 카드에 적혀 있는 모든 수는 0으로 시작하지 않는다 (즉, 15를 적는 방법은 ‘15’로 유일하며, ‘0015’처럼 적혀 있지는 않다.).

&nbsp; 각 카드의 앞면을 위로 둘 지, 뒷면을 위로 둘 지 결정한 뒤 카드를 탁자 위에 놓자. 이제 카드를 일렬로 배열하여 카드 위쪽에 적힌 수들을 차례대로 읽어 하나의 커다란 수를 만들 수 있을 것이다. (카드에 적힌 수를 뒤집을 수는 없으며, 적혀 있는 수 그대로 읽어야 한다.) 당신은 카드를 적당히 배열하여 가능한 한 작은 수를 만들고자 한다.

&nbsp; 각각의 카드의 앞면 또는 뒷면을 위로 둘 지 결정하는 모든 2^N가지의 방법에 대해, 윗 문단의 방법으로 만들 수 있는 가장 작은 수를 구한 뒤, 이를 모두 더한 수를 10^9+7로 나눈 나머지를 구하는 프로그램을 작성하라.

## 입력

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 카드의 개수 N (1≤N≤100)이 주어진다. 다음 N개의 줄에는 카드에 적혀 있는 자연수들에 대한 정보가 주어진다. 이 중 i (1≤i≤N)번째 줄에는 두 개의 자연수 ai, bi (1 ≤ ai, bi ≤ 10<sup>30</sup>)가 공백 하나를 사이로 두고 주어진다. 10<sup>30</sup>-1는 굉장히 큰 수로 64비트 정수로 저장할 수 없다는 점에 유의하라.

## 출력

&nbsp; 각 테스트 케이스마다, 문제의 정답을 출력한다.

- <table>
  <tr>
  <th align="center">예제 입력 1</th>
  <th align="center">예제 출력 1</th>
  </tr>
  <tr>
  <td valign="top">

  ```txt
  3
  2
  1 2
  2 1
  1
  20 20
  3
  123456789 987654321
  1231931313891221919123 1
  2191831938193913139239 1
  ```

  </td>
  <td valign="top">

  ```txt
  #1 57
  #2 40
  #3 692388510
  ```

  </td>
  </tr>
  </table>
